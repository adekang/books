[
  {
    "text": "1.开篇：用正确的方式学习 TypeScript",
    "link": "/docs/ts-playground/1.开篇：用正确的方式学习 TypeScript"
  },
  {
    "text": "2.工欲善其事：打造最舒适的 TypeScript 开发环境",
    "link": "/docs/ts-playground/2.工欲善其事：打造最舒适的 TypeScript 开发环境"
  },
  {
    "text": "3.进入类型的世界：理解原始类型与对象类型",
    "link": "/docs/ts-playground/3.进入类型的世界：理解原始类型与对象类型"
  },
  {
    "text": "4.掌握字面量类型与枚举，让你的类型再精确一些",
    "link": "/docs/ts-playground/4.掌握字面量类型与枚举，让你的类型再精确一些"
  },
  {
    "text": "5.函数与 Class 中的类型：详解函数重载与面向对象",
    "link": "/docs/ts-playground/5.函数与 Class 中的类型：详解函数重载与面向对象"
  },
  {
    "text": "6.探秘内置类型：any、unknown、never 与类型断言",
    "link": "/docs/ts-playground/6.探秘内置类型：any、unknown、never 与类型断言"
  },
  {
    "text": "7.类型编程好帮手：TypeScript 类型工具（上）",
    "link": "/docs/ts-playground/7.类型编程好帮手：TypeScript 类型工具（上）"
  },
  {
    "text": "8.类型编程好帮手：TypeScript 类型工具（下）",
    "link": "/docs/ts-playground/8.类型编程好帮手：TypeScript 类型工具（下）"
  },
  {
    "text": "9.类型编程基石：TypeScript 中无处不在的泛型",
    "link": "/docs/ts-playground/9.类型编程基石：TypeScript 中无处不在的泛型"
  },
  {
    "text": "10.结构化类型系统：类型兼容性判断的幕后",
    "link": "/docs/ts-playground/10.结构化类型系统：类型兼容性判断的幕后"
  },
  {
    "text": "11.类型系统层级：从 Top Type 到 Bottom Type",
    "link": "/docs/ts-playground/11.类型系统层级：从 Top Type 到 Bottom Type"
  },
  {
    "text": "12.类型里的逻辑运算：条件类型与 infer",
    "link": "/docs/ts-playground/12.类型里的逻辑运算：条件类型与 infer"
  },
  {
    "text": "13.内置工具类型基础：别再妖魔化工具类型了！",
    "link": "/docs/ts-playground/13.内置工具类型基础：别再妖魔化工具类型了！"
  },
  {
    "text": "14.反方向类型推导：用好上下文相关类型",
    "link": "/docs/ts-playground/14.反方向类型推导：用好上下文相关类型"
  },
  {
    "text": "15.数类型：协变与逆变的比较",
    "link": "/docs/ts-playground/15.数类型：协变与逆变的比较"
  },
  {
    "text": "16.了解类型编程与类型体操的意义，找到平衡点",
    "link": "/docs/ts-playground/16.了解类型编程与类型体操的意义，找到平衡点"
  },
  {
    "text": "17.内置工具类型进阶：类型编程进阶",
    "link": "/docs/ts-playground/17.内置工具类型进阶：类型编程进阶"
  },
  {
    "text": "18.基础类型新成员：模板字符串类型入门",
    "link": "/docs/ts-playground/18.基础类型新成员：模板字符串类型入门"
  },
  {
    "text": "19.类型编程新范式：模板字符串工具类型进阶",
    "link": "/docs/ts-playground/19.类型编程新范式：模板字符串工具类型进阶"
  },
  {
    "text": "20.工程层面的类型能力：类型声明、类型指令与命名空间",
    "link": "/docs/ts-playground/20.工程层面的类型能力：类型声明、类型指令与命名空间"
  },
  {
    "text": "21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位",
    "link": "/docs/ts-playground/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位"
  },
  {
    "text": "22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍",
    "link": "/docs/ts-playground/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍"
  },
  {
    "text": "23.全链路 TypeScript 工具库，找到适合你的工具",
    "link": "/docs/ts-playground/23.全链路 TypeScript 工具库，找到适合你的工具"
  },
  {
    "text": "24.说说 TypeScript 和 ECMAScript 之间那些事儿",
    "link": "/docs/ts-playground/24.说说 TypeScript 和 ECMAScript 之间那些事儿"
  },
  {
    "text": "25.装饰器与反射元数据：了解装饰器基本原理与应用",
    "link": "/docs/ts-playground/25.装饰器与反射元数据：了解装饰器基本原理与应用"
  },
  {
    "text": "26.控制反转与依赖注入：基于装饰器的依赖注入实现",
    "link": "/docs/ts-playground/26.控制反转与依赖注入：基于装饰器的依赖注入实现"
  },
  {
    "text": "27.TSConfig 全解（上）：构建相关配置",
    "link": "/docs/ts-playground/27.TSConfig 全解（上）：构建相关配置"
  },
  {
    "text": "28.TSConfig 全解（下）：检查相关、工程相关配置",
    "link": "/docs/ts-playground/28.TSConfig 全解（下）：检查相关、工程相关配置"
  },
  {
    "text": "29.基于 Prisma + NestJs 的 Node API ：前置知识储备",
    "link": "/docs/ts-playground/29.基于 Prisma + NestJs 的 Node API ：前置知识储备"
  },
  {
    "text": "30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署",
    "link": "/docs/ts-playground/30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署"
  },
  {
    "text": "31.玩转 TypeScript AST：AST Checker 与 CodeMod",
    "link": "/docs/ts-playground/31.玩转 TypeScript AST：AST Checker 与 CodeMod"
  },
  {
    "text": "32.感谢相伴：是结束，也是开始",
    "link": "/docs/ts-playground/32.感谢相伴：是结束，也是开始"
  },
  {
    "text": "33.漫谈篇：面试中的 TypeScript",
    "link": "/docs/ts-playground/33.漫谈篇：面试中的 TypeScript"
  }
]